<?xml version="1.0" encoding="UTF-8" ?>
<project name="Arc" id="Project_33931c4" template="Default" database="PostgreSQL" >
	<schema name="arc" catalogname="arc" schemaname="arc" >
		<table name="scenarios" >
			<column name="id" type="integer" length="10" decimal="0" jt="4" mandatory="y" >
				<type_extra>GENERATED BY DEFAULT AS IDENTITY</type_extra>
			</column>
			<column name="description" type="text" jt="12" mandatory="y" />
			<column name="title" type="text" jt="12" mandatory="y" />
			<index name="pk_scenarios_id" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
		</table>
		<table name="test_table" >
			<column name="id" type="integer" length="10" decimal="0" jt="4" mandatory="y" >
				<type_extra>GENERATED BY DEFAULT AS IDENTITY</type_extra>
			</column>
			<column name="foo" type="text" decimal="0" jt="12" />
			<index name="test_table_pk" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
		</table>
		<sequence name="scenarios_id_seq" />
		<sequence name="test_table_id_seq" />
		<procedure name="login" id="Procedure_18d0731" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION arc.login(email text, pass text)
 RETURNS basic_auth.jwt_token
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  _role name;
  result basic_auth.jwt_token;
begin
  -- check email and password
  select basic_auth.user_role(email, pass) into _role;
  if _role is null then
    raise invalid_password using message = 'invalid user or password';
  end if;
  select sign(
      row_to_json(r), 'reallyreallyreallyreallyverysafe'
    ) as token
    from (
      select _role as role, login.email as email,
         extract(epoch from now())::integer + 60*60 as exp
    ) r
    into result;
  return result;
end;
$function$
;]]></string>
			<input_param name="token" jt="12" type="text" />
			<input_param name="email" jt="12" type="text" />
			<input_param name="pass" jt="12" type="text" />
		</procedure>
		<procedure name="signup" id="Procedure_9ac6d0" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION arc.signup(name text, email text, pass text)
 RETURNS basic_auth.jwt_token
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
    _role name;
    result basic_auth.jwt_token;
begin
    -- check email and password
    insert into basic_auth.users (name, email, pass, role)
    values (signup.name, signup.email, signup.pass, 'webuser');
    select basic_auth.user_role(email, pass) into _role;
    if _role is null then
        raise invalid_password using message = 'invalid user or password';
    end if;
    select sign(
                   row_to_json(r), 'reallyreallyreallyreallyverysafe'
               ) as token
    from (
             select _role as role, signup.email as email,
                    extract(epoch from now())::integer + 60*60 as exp
         ) r
    into result;
    return result;
end;
$function$
;]]></string>
			<input_param name="token" jt="12" type="text" />
			<input_param name="name" jt="12" type="text" />
			<input_param name="email" jt="12" type="text" />
			<input_param name="pass" jt="12" type="text" />
		</procedure>
	</schema>
	<schema name="basic_auth" catalogname="arc" schemaname="basic_auth" >
		<table name="users" >
			<column name="id" type="integer" length="10" decimal="0" jt="4" mandatory="y" >
				<type_extra>GENERATED BY DEFAULT AS IDENTITY</type_extra>
			</column>
			<column name="name" type="text" decimal="0" jt="12" mandatory="y" />
			<column name="email" type="text" decimal="0" jt="12" mandatory="y" />
			<column name="pass" type="text" decimal="0" jt="12" mandatory="y" />
			<column name="role" type="name" decimal="0" jt="12" mandatory="y" />
			<index name="users_pkey" unique="PRIMARY_KEY" >
				<column name="id" />
			</index>
			<constraint name="users_name_check" >
				<string>length(name) &lt; 512</string>
			</constraint>
			<constraint name="users_email_check" >
				<string>email ~* &#039;^.+@.+\..+$&#039;::text</string>
			</constraint>
			<constraint name="users_pass_check" >
				<string>length(pass) &lt; 512</string>
			</constraint>
			<constraint name="users_role_check" >
				<string>length((role)::text) &lt; 512</string>
			</constraint>
		</table>
		<sequence name="users_id_seq" />
		<procedure name="check_role_exists" id="Procedure_50c13e4" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION basic_auth.check_role_exists()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if not exists (select 1 from pg_roles as r where r.rolname = new.role) then
    raise foreign_key_violation using message =
      'unknown database role: ' || new.role;
    return null;
  end if;
  return new;
end
$function$
;]]></string>
			<result_param name="returnValue" jt="1111" type="trigger" />
		</procedure>
		<procedure name="encrypt_pass" id="Procedure_511c93f" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION basic_auth.encrypt_pass()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if tg_op = 'INSERT' or new.pass <> old.pass then
    new.pass = crypt(new.pass, gen_salt('bf'));
  end if;
  return new;
end
$function$
;]]></string>
			<result_param name="returnValue" jt="1111" type="trigger" />
		</procedure>
		<procedure name="user_role" id="Procedure_1ea9ca7" isSystem="false" params_known="y" >
			<string><![CDATA[CREATE OR REPLACE FUNCTION basic_auth.user_role(email text, pass text)
 RETURNS name
 LANGUAGE plpgsql
AS $function$
begin
  return (
  select role from basic_auth.users
   where users.email = user_role.email
     and users.pass = crypt(user_role.pass, users.pass)
  );
end;
$function$
;]]></string>
			<input_param name="email" jt="12" type="text" />
			<input_param name="pass" jt="12" type="text" />
			<result_param name="returnValue" jt="12" type="name" />
		</procedure>
		<trigger name="encrypt_pass" table="users" id="Trigger_4d68da3" isSystem="false" >
			<string><![CDATA[CREATE TRIGGER encrypt_pass BEFORE INSERT OR UPDATE ON basic_auth.users FOR EACH ROW EXECUTE PROCEDURE basic_auth.encrypt_pass()]]></string>
		</trigger>
		<trigger name="ensure_user_role_exists" table="users" id="Trigger_19ef4e0" isSystem="false" >
			<string><![CDATA[CREATE CONSTRAINT TRIGGER ensure_user_role_exists AFTER INSERT OR UPDATE ON basic_auth.users NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE PROCEDURE basic_auth.check_role_exists()]]></string>
		</trigger>
	</schema>
	<connector name="Arc" database="PostgreSQL" driver_class="org.postgresql.Driver" driver_jar="postgresql-42.2.7.jar" driver_desc="Standard" host="35.239.204.157" port="5432" instance="arc" user="hao" passwd="aGFvZGFuZzI=" />
	<layout name="Sample Layout with Tools" id="Layout_5d0a039" show_column_type="y" show_relation="columns" >
		<entity schema="arc" name="test_table" color="3986C1" x="48" y="48" />
		<entity schema="arc" name="scenarios" color="C1D8EE" x="368" y="64" />
		<script name="Sample SQL Editor" id="Editor_2c71f05" language="SQL" >
			<string><![CDATA[SELECT * 
FROM
	arc.test_table e;]]></string>
		</script>
		<browser id="Browse_17e1d32" name="Sample Relational Data Browse" confirm_updates="y" >
			<browse_table schema="arc" entity="test_table" x="20" y="20" width="400" height="300" />
		</browser>
		<query id="Query_110a1bb" name="Sample Query Builder" >
			<query_table schema="arc" name="test_table" alias="tt" x="48" y="48" >
				<column name="id" />
				<column name="foo" />
			</query_table>
		</query>
	</layout>
	<layout name="arc" id="Layout_1638a5a" show_relation="columns" >
		<entity schema="arc" name="test_table" color="3986C1" x="48" y="48" />
	</layout>
	<layout name="basic_auth" id="Layout_5dc1310" show_relation="columns" >
		<entity schema="basic_auth" name="users" color="3986C1" x="48" y="48" />
	</layout>
</project>